window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "qrotor", "modulename": "qrotor", "kind": "module", "doc": "<h1 id=\"qrotor\">QRotor</h1>\n\n<p>QRotor is a Python package used to study molecular rotations,\nsuch as those of methyl and amine groups.\nIt can calculate their quantum energy levels and wavefunctions,\nalong with excitations and tunnel splittings.\nThese quantum systems are represented by the <code>qrotor.System()</code> object.</p>\n\n<p>QRotor can obtain custom potentials from DFT,\nwhich are used to solve the quantum system.</p>\n\n<h1 id=\"index\">Index</h1>\n\n<table>\n<thead>\n<tr>\n  <th></th>\n  <th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td><code>qrotor.system</code></td>\n  <td>Definition of the quantum <code>System</code> object</td>\n</tr>\n<tr>\n  <td><code>qrotor.systems</code></td>\n  <td>Functions to manage several System objects, such as a list of systems</td>\n</tr>\n<tr>\n  <td><code>qrotor.rotate</code></td>\n  <td>Rotate specific atoms from structural files</td>\n</tr>\n<tr>\n  <td><code>qrotor.constants</code></td>\n  <td>Common bond lengths and inertias</td>\n</tr>\n<tr>\n  <td><code>qrotor.potential</code></td>\n  <td>Potential definitions and loading functions</td>\n</tr>\n<tr>\n  <td><code>qrotor.solve</code></td>\n  <td>Solve rotation eigenvalues and eigenvectors</td>\n</tr>\n<tr>\n  <td><code>qrotor.plot</code></td>\n  <td>Plotting functions</td>\n</tr>\n</tbody>\n</table>\n\n<h1 id=\"usage\">Usage</h1>\n\n<h2 id=\"solving-quantum-rotational-systems\">Solving quantum rotational systems</h2>\n\n<p>A basic calculation of the eigenvalues for a zero potential goes as follows.\nNote that the default energy unit is meV unless stated otherwise.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">qrotor</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">qr</span>\n<span class=\"n\">system</span> <span class=\"o\">=</span> <span class=\"n\">qr</span><span class=\"o\">.</span><span class=\"n\">System</span><span class=\"p\">()</span>\n<span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">gridsize</span> <span class=\"o\">=</span> <span class=\"mi\">200000</span>  <span class=\"c1\"># Size of the potential grid</span>\n<span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">B</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>  <span class=\"c1\"># Rotational inertia</span>\n<span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">potential_name</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;zero&#39;</span>\n<span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">solve</span><span class=\"p\">()</span>\n<span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">eigenvalues</span>\n<span class=\"c1\"># [0.0, 1.0, 1.0, 4.0, 4.0, 9.0, 9.0, ...]  # approx values</span>\n</code></pre>\n</div>\n\n<p>The accuracy of the calculation increases with bigger gridsizes,\nbut note that the runtime increases exponentially.</p>\n\n<p>The same calculation can be performed for a methyl group,\nin a cosine potential of amplitude 30 meV:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">qrotor</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">qr</span>\n<span class=\"n\">system</span> <span class=\"o\">=</span> <span class=\"n\">qr</span><span class=\"o\">.</span><span class=\"n\">System</span><span class=\"p\">()</span>\n<span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">gridsize</span> <span class=\"o\">=</span> <span class=\"mi\">200000</span>  <span class=\"c1\"># Size of the potential grid</span>\n<span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">B</span> <span class=\"o\">=</span> <span class=\"n\">qr</span><span class=\"o\">.</span><span class=\"n\">B_CH3</span>  <span class=\"c1\"># Rotational inertia of a methyl group</span>\n<span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">potential_name</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;cosine&#39;</span>\n<span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">potential_constants</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">30</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span>  <span class=\"c1\"># Offset, max, freq, phase (for cos pot.)</span>\n<span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">solve</span><span class=\"p\">()</span>\n<span class=\"c1\"># Plot potential and eigenvalues</span>\n<span class=\"n\">qr</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"o\">.</span><span class=\"n\">energies</span><span class=\"p\">(</span><span class=\"n\">system</span><span class=\"p\">)</span>\n<span class=\"c1\"># Plot the first wavefunctions</span>\n<span class=\"n\">qr</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"o\">.</span><span class=\"n\">wavefunction</span><span class=\"p\">(</span><span class=\"n\">system</span><span class=\"p\">,</span> <span class=\"n\">levels</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"n\">square</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<h2 id=\"custom-potentials-from-dft\">Custom potentials from DFT</h2>\n\n<p>QRotor can be used to obtain custom rotational potentials from DFT calculations.\nUsing Quantum ESPRESSO, running an SCF calculation for a methyl rotation every 10 degrees:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">qrotor</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nn\">qr</span>\n<span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"nn\">aton</span><span class=\"w\"> </span><span class=\"kn\">import</span> <span class=\"n\">api</span>\n<span class=\"c1\"># Approx crystal positions of the atoms to rotate</span>\n<span class=\"n\">atoms</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n    <span class=\"s1\">&#39;1.101   1.204   1.307&#39;</span>\n    <span class=\"s1\">&#39;2.102   2.205   2.308&#39;</span>\n    <span class=\"s1\">&#39;3.103   3.206   3.309&#39;</span>\n<span class=\"p\">]</span>\n<span class=\"c1\"># Create the input SCF files, saving the filenames to a list</span>\n<span class=\"n\">scf_files</span> <span class=\"o\">=</span> <span class=\"n\">qr</span><span class=\"o\">.</span><span class=\"n\">rotate</span><span class=\"o\">.</span><span class=\"n\">structure_qe</span><span class=\"p\">(</span><span class=\"s1\">&#39;molecule.in&#39;</span><span class=\"p\">,</span> <span class=\"n\">positions</span><span class=\"o\">=</span><span class=\"n\">atoms</span><span class=\"p\">,</span> <span class=\"n\">angle</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"n\">repeat</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"c1\"># Run the Quantum ESPRESSO calculations</span>\n<span class=\"n\">api</span><span class=\"o\">.</span><span class=\"n\">slurm</span><span class=\"o\">.</span><span class=\"n\">sbatch</span><span class=\"p\">(</span><span class=\"n\">files</span><span class=\"o\">=</span><span class=\"n\">scf_files</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>To load the calculated potential to a QRotor System,</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"c1\"># Compile a &#39;potential.csv&#39; file with the calculated potential as a function of the angle</span>\n<span class=\"n\">qr</span><span class=\"o\">.</span><span class=\"n\">potential</span><span class=\"o\">.</span><span class=\"n\">from_qe</span><span class=\"p\">()</span>\n<span class=\"c1\"># Load to the system</span>\n<span class=\"n\">system</span> <span class=\"o\">=</span> <span class=\"n\">qr</span><span class=\"o\">.</span><span class=\"n\">potential</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">()</span>\n<span class=\"c1\"># Solve the system, interpolating to a bigger gridsize</span>\n<span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">B</span> <span class=\"o\">=</span> <span class=\"n\">qr</span><span class=\"o\">.</span><span class=\"n\">B_CH3</span>\n<span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">solve</span><span class=\"p\">(</span><span class=\"mi\">200000</span><span class=\"p\">)</span>\n<span class=\"n\">qr</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"o\">.</span><span class=\"n\">energies</span><span class=\"p\">(</span><span class=\"n\">system</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<h2 id=\"tunnel-splittings-and-excitations\">Tunnel splittings and excitations</h2>\n\n<p>Tunnel splittings, excitations and energy level degeneracy\nbelow the potential maximum are also calculated upon solving the system:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">solve</span><span class=\"p\">()</span>\n<span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">splittings</span>\n<span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">excitations</span>\n<span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">deg</span>\n</code></pre>\n</div>\n\n<p>An integer <code>System.deg</code> degeneracy (e.g. 3 for methyls)\nindicates that the energy levels have been properly estimated.\nHowever, if the degeneracy is a float instead,\nplease check the splittings and excitations manually from the system eigenvalues.</p>\n\n<p>To export the energies and the tunnel splittings of several calculations to a CSV file:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">calculations</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">system1</span><span class=\"p\">,</span> <span class=\"n\">system2</span><span class=\"p\">,</span> <span class=\"n\">system3</span><span class=\"p\">]</span>\n<span class=\"n\">qr</span><span class=\"o\">.</span><span class=\"n\">systems</span><span class=\"o\">.</span><span class=\"n\">save_energies</span><span class=\"p\">(</span><span class=\"n\">calculations</span><span class=\"p\">)</span>\n<span class=\"n\">qr</span><span class=\"o\">.</span><span class=\"n\">systems</span><span class=\"o\">.</span><span class=\"n\">save_splittings</span><span class=\"p\">(</span><span class=\"n\">calculations</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p>Excitations are calculated using the mean for each energy level\nwith respect to the ground state.\nTunnel splittings for each level are calculated as the difference between A and E,\nconsidering the mean of the eigenvalues for each sublevel.\nSee <a href=\"https://doi.org/10.1119/1.1538575\">R. M. Dimeo, American Journal of Physics 71, 885\u2013893 (2003)</a>\nand <a href=\"https://doi.org/10.1016/S0079-6565(99)00016-3\">A. J. Horsewill, Progress in Nuclear Magnetic Resonance Spectroscopy 35, 359\u2013389 (1999)</a>\nfor further reference.</p>\n"}, {"fullname": "qrotor.constants", "modulename": "qrotor.constants", "kind": "module", "doc": "<h1 id=\"description\">Description</h1>\n\n<p>Common constants and default inertia values used in the QRotor subpackage.</p>\n\n<p>Bond lengths and angles were obtained from MAPbI3, see\n<a href=\"https://doi.org/10.1021/acs.cgd.3c01112\">K. Dru\u017cbicki <em>et al</em>., Crystal Growth &amp; Design 24, 391\u2013404 (2024)</a>.</p>\n\n<hr />\n"}, {"fullname": "qrotor.constants.distance_CH", "modulename": "qrotor.constants", "qualname": "distance_CH", "kind": "variable", "doc": "<p>Distance of the C-H bond, in Angstroms.</p>\n", "default_value": "1.09285"}, {"fullname": "qrotor.constants.distance_NH", "modulename": "qrotor.constants", "qualname": "distance_NH", "kind": "variable", "doc": "<p>Distance of the N-H bond, in Angstroms.</p>\n", "default_value": "1.040263"}, {"fullname": "qrotor.constants.angle_CH_external", "modulename": "qrotor.constants", "qualname": "angle_CH_external", "kind": "variable", "doc": "<p>External angle of the X-C-H bond, in degrees.</p>\n", "default_value": "108.7223"}, {"fullname": "qrotor.constants.angle_NH_external", "modulename": "qrotor.constants", "qualname": "angle_NH_external", "kind": "variable", "doc": "<p>External angle of the X-N-H bond, in degrees.</p>\n", "default_value": "111.29016"}, {"fullname": "qrotor.constants.angle_CH", "modulename": "qrotor.constants", "qualname": "angle_CH", "kind": "variable", "doc": "<p>Internal angle of the X-C-H bond, in degrees.</p>\n", "default_value": "71.2777"}, {"fullname": "qrotor.constants.angle_NH", "modulename": "qrotor.constants", "qualname": "angle_NH", "kind": "variable", "doc": "<p>Internal angle of the X-N-H bond, in degrees.</p>\n", "default_value": "68.70984"}, {"fullname": "qrotor.constants.r_CH", "modulename": "qrotor.constants", "qualname": "r_CH", "kind": "variable", "doc": "<p>Rotation radius of the methyl group, in meters.</p>\n", "default_value": "np.float64(1.0350223020441665e-10)"}, {"fullname": "qrotor.constants.r_NH", "modulename": "qrotor.constants", "qualname": "r_NH", "kind": "variable", "doc": "<p>Rotation radius of the amine group, in meters.</p>\n", "default_value": "np.float64(9.69268793902999e-11)"}, {"fullname": "qrotor.constants.I_CH3", "modulename": "qrotor.constants", "qualname": "I_CH3", "kind": "variable", "doc": "<p>Inertia of CH3, in kg\u00b7m^2.</p>\n", "default_value": "np.float64(5.37903596799128e-47)"}, {"fullname": "qrotor.constants.I_CD3", "modulename": "qrotor.constants", "qualname": "I_CD3", "kind": "variable", "doc": "<p>Inertia of CD3, in kg\u00b7m^2.</p>\n", "default_value": "np.float64(1.0748582164136045e-46)"}, {"fullname": "qrotor.constants.I_NH3", "modulename": "qrotor.constants", "qualname": "I_NH3", "kind": "variable", "doc": "<p>Inertia of NH3, in kg\u00b7m^2.</p>\n", "default_value": "np.float64(4.717299973303422e-47)"}, {"fullname": "qrotor.constants.I_ND3", "modulename": "qrotor.constants", "qualname": "I_ND3", "kind": "variable", "doc": "<p>Inertia of ND3, in kg\u00b7m^2.</p>\n", "default_value": "np.float64(9.426277618824576e-47)"}, {"fullname": "qrotor.constants.B_CH3", "modulename": "qrotor.constants", "qualname": "B_CH3", "kind": "variable", "doc": "<p>Rotational energy of CH3, in meV\u00b7s/kg\u00b7m^2.</p>\n", "default_value": "np.float64(0.6452195002679675)"}, {"fullname": "qrotor.constants.B_CD3", "modulename": "qrotor.constants", "qualname": "B_CD3", "kind": "variable", "doc": "<p>Rotational energy of CD3, in meV\u00b7s/kg\u00b7m^2.</p>\n", "default_value": "np.float64(0.32289457773984676)"}, {"fullname": "qrotor.constants.B_NH3", "modulename": "qrotor.constants", "qualname": "B_NH3", "kind": "variable", "doc": "<p>Rotational energy of NH3, in meV\u00b7s/kg\u00b7m^2.</p>\n", "default_value": "np.float64(0.7357299554474442)"}, {"fullname": "qrotor.constants.B_ND3", "modulename": "qrotor.constants", "qualname": "B_ND3", "kind": "variable", "doc": "<p>Rotational energy of ND3, in meV\u00b7s/kg\u00b7m^2.</p>\n", "default_value": "np.float64(0.36818976053280467)"}, {"fullname": "qrotor.constants.constants_titov2023", "modulename": "qrotor.constants", "qualname": "constants_titov2023", "kind": "variable", "doc": "<p>Potential constants from\n<a href=\"https://link.aps.org/doi/10.1103/PhysRevMaterials.7.073402\">K. Titov et al., Phys. Rev. Mater. 7, 073402 (2023)</a>\nfor the <code>qrotor.potential.titov2023</code> potential.\nIn meV units.</p>\n", "default_value": "[[2.786, 0.013, -1.5284, -0.0037, -1.2791], [2.6507, 0.0158, -1.4111, -0.0007, -1.2547], [2.1852, 0.0164, -1.0017, 0.0003, -1.2061], [5.9109, 0.0258, -7.0152, -0.0168, 1.0213], [1.4526, 0.0134, -0.3196, 0.0005, -1.1461]]"}, {"fullname": "qrotor.plot", "modulename": "qrotor.plot", "kind": "module", "doc": "<h1 id=\"description\">Description</h1>\n\n<p>This module provides straightforward functions to plot QRotor data.</p>\n\n<h1 id=\"index\">Index</h1>\n\n<table>\n<thead>\n<tr>\n  <th></th>\n  <th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td><code>potential()</code></td>\n  <td>Potential values as a function of the angle</td>\n</tr>\n<tr>\n  <td><code>energies()</code></td>\n  <td>Calculated eigenvalues</td>\n</tr>\n<tr>\n  <td><code>reduced_energies()</code></td>\n  <td>Reduced energies E/B as a function of the reduced potential V/B</td>\n</tr>\n<tr>\n  <td><code>wavefunction()</code></td>\n  <td>Selected wavefunctions or squared wavefunctions of a system</td>\n</tr>\n<tr>\n  <td><code>splittings()</code></td>\n  <td>Tunnel splitting energies of a list of systems</td>\n</tr>\n<tr>\n  <td><code>convergence()</code></td>\n  <td>Energy convergence</td>\n</tr>\n</tbody>\n</table>\n\n<hr />\n"}, {"fullname": "qrotor.plot.potential", "modulename": "qrotor.plot", "qualname": "potential", "kind": "function", "doc": "<p>Plot the potential values of <code>data</code> (System object, or list of systems).</p>\n\n<p>Title can be customized with <code>title</code>.\nIf empty, system[0].comment will be used as title if no more comments are present.</p>\n\n<p><code>marker</code> and <code>linestyle</code> can be a Matplotlib string or list of strings.\nOptionally, the Viridis colormap can be used with <code>cm = True</code>.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span>,</span><span class=\"param\">\t<span class=\"n\">title</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">marker</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">linestyle</span><span class=\"o\">=</span><span class=\"s1\">&#39;-&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">cm</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "qrotor.plot.energies", "modulename": "qrotor.plot", "qualname": "energies", "kind": "function", "doc": "<p>Plot the eigenvalues of <code>data</code> (System or a list of System objects).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">title</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "qrotor.plot.reduced_energies", "modulename": "qrotor.plot", "qualname": "reduced_energies", "kind": "function", "doc": "<p>Plots the reduced energy of the system E/B vs the reduced potential energy V/B.</p>\n\n<p>Takes a <code>data</code> list of System objects as input.\nAn optional <code>title</code> can be specified.</p>\n\n<p>Optional maximum reduced potential <code>values</code> are plotted\nas vertical lines (floats or ints) or regions\n(lists inside the values list, from min to max).\nA <code>legend</code> of the same len as <code>values</code> can be included.\nThese values are assumed to be divided by B by the user.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"nb\">list</span>,</span><span class=\"param\">\t<span class=\"n\">title</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">values</span><span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>,</span><span class=\"param\">\t<span class=\"n\">legend</span><span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"o\">=</span> <span class=\"p\">[]</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "qrotor.plot.wavefunction", "modulename": "qrotor.plot", "qualname": "wavefunction", "kind": "function", "doc": "<p>Plot the wavefunction of a <code>system</code> for the specified <code>levels</code>.</p>\n\n<p>Wavefunctions are squared by default, showing the probabilities;\nTo show the actual wavefunctions, set <code>square = False</code>.</p>\n\n<p><code>levels</code> can be a list of indexes, or the number of levels to plot.</p>\n\n<p>Specific wavefunctions can be overlapped with <code>overlap</code> as a list with the target indexes.\nThe <code>overlap</code> value can also be the max number of wavefunctions to add.\nAll found wavefunctions can be added together with <code>overlap = True</code>;\nbut note that this overlap is limited by the number of System.searched_E,\nthat must be specified before solving the system.\nSetting <code>overlap</code> will ignore the <code>levels</code> argument.</p>\n\n<p>Set <code>yticks = True</code> to plot the wavefunction yticks.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">system</span><span class=\"p\">:</span> <span class=\"n\">qrotor</span><span class=\"o\">.</span><span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">System</span>,</span><span class=\"param\">\t<span class=\"n\">title</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">square</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">levels</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">overlap</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">yticks</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "qrotor.plot.splittings", "modulename": "qrotor.plot", "qualname": "splittings", "kind": "function", "doc": "<p>Plot the tunnel splitting energies of a <code>data</code> list of systems.</p>\n\n<p>The different <code>System.comment</code> are shown in the horizontal axis.\nAn optional <code>title</code> can be specified.\nDefault units shown are $\\mu$eV (<code>'ueV'</code>).\nAvailable units are: <code>'ueV'</code>, <code>'meV'</code>, <code>'Ry'</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"nb\">list</span>, </span><span class=\"param\"><span class=\"n\">title</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">units</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;ueV&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "qrotor.plot.convergence", "modulename": "qrotor.plot", "qualname": "convergence", "kind": "function", "doc": "<p>Plot the energy convergence of a <code>data</code> list of Systems as a function of the gridsize.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "qrotor.potential", "modulename": "qrotor.potential", "kind": "module", "doc": "<h1 id=\"description\">Description</h1>\n\n<p>This module contains functions to calculate the actual <code>potential_values</code> of the system.</p>\n\n<h1 id=\"index\">Index</h1>\n\n<p>User functions:</p>\n\n<table>\n<thead>\n<tr>\n  <th></th>\n  <th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td><code>save()</code></td>\n  <td>Save the potential from a System to a data file</td>\n</tr>\n<tr>\n  <td><code>load()</code></td>\n  <td>Load a System with a custom potential from a potential data file</td>\n</tr>\n<tr>\n  <td><code>from_qe()</code></td>\n  <td>Creates a potential data file from Quantum ESPRESSO outputs</td>\n</tr>\n<tr>\n  <td><code>merge()</code></td>\n  <td>Add and subtract potentials from systems</td>\n</tr>\n<tr>\n  <td><code>scale()</code></td>\n  <td>Scale potential values by a given factor</td>\n</tr>\n</tbody>\n</table>\n\n<p>To solve the system, optionally interpolating to a new gridsize, use the <code>System.solve(gridsize)</code> method.<br />\nHowever, if you just want to quickly solve or interpolate the potential, check the <code>System.solve_potential(gridsize)</code> method.\nThis will run several checks before applying the following functions automatically:</p>\n\n<table>\n<thead>\n<tr>\n  <th></th>\n  <th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td><code>interpolate()</code></td>\n  <td>Interpolates the current <code>System.potential_values</code> to a new <code>System.gridsize</code></td>\n</tr>\n<tr>\n  <td><code>solve()</code></td>\n  <td>Solve the potential values based on the potential name</td>\n</tr>\n</tbody>\n</table>\n\n<p>A synthetic potential can be created by specifying its name in <code>System.potential_name</code>,\nalong with the corresponding <code>System.potential_constants</code> if required.\nAvailable potentials are:</p>\n\n<table>\n<thead>\n<tr>\n  <th></th>\n  <th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td><code>zero()</code></td>\n  <td>Zero potential</td>\n</tr>\n<tr>\n  <td><code>sine()</code></td>\n  <td>Sine potential</td>\n</tr>\n<tr>\n  <td><code>cosine()</code></td>\n  <td>Cosine potential</td>\n</tr>\n<tr>\n  <td><code>titov2023()</code></td>\n  <td>Potential of the hindered methyl rotor, as in titov2023.</td>\n</tr>\n</tbody>\n</table>\n\n<hr />\n"}, {"fullname": "qrotor.potential.save", "modulename": "qrotor.potential", "qualname": "save", "kind": "function", "doc": "<p>Save the rotational potential from a <code>system</code> to a CSV file.</p>\n\n<p>The output <code>filepath</code> contains angle and energy columns,\nin degrees and meVs by default.\nThe units can be changed with <code>angle</code> and <code>energy</code>,\nbut only change these defaults if you know what you are doing.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">system</span><span class=\"p\">:</span> <span class=\"n\">qrotor</span><span class=\"o\">.</span><span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">System</span>,</span><span class=\"param\">\t<span class=\"n\">comment</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">filepath</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;potential.csv&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">angle</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;deg&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">energy</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;meV&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "qrotor.potential.load", "modulename": "qrotor.potential", "qualname": "load", "kind": "function", "doc": "<p>Read a rotational potential energy datafile.</p>\n\n<p>The input file in <code>filepath</code> should contain two columns with angle and potential energy values.\nDegrees and meV are assumed as default units unless stated in <code>angle</code> and <code>energy</code>.\nUnits will be converted automatically to radians and meV.</p>\n\n<p>An optional <code>comment</code> can be included in the output System.\nSet to the parent folder name by default.</p>\n\n<p>A previous System object can be provided through <code>system</code> to update its potential values.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">filepath</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;potential.csv&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">comment</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">system</span><span class=\"p\">:</span> <span class=\"n\">qrotor</span><span class=\"o\">.</span><span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">System</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">angle</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;deg&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">energy</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;meV&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">qrotor</span><span class=\"o\">.</span><span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">System</span>:</span></span>", "funcdef": "def"}, {"fullname": "qrotor.potential.from_qe", "modulename": "qrotor.potential", "qualname": "from_qe", "kind": "function", "doc": "<p>Compiles a rotational potential CSV file from Quantum ESPRESSO outputs,\ncreated with <code>qrotor.rotate.structure_qe()</code>.</p>\n\n<p>The angle in degrees is extracted from the output filenames,\nwhich must follow <code>whatever_ANGLE.out</code>.</p>\n\n<p>Outputs from SCF calculations must be located in the provided <code>folder</code> (CWD if None).\nFiles can be filtered by those containing the specified <code>include</code> filters,\nexcluding those containing any string from the <code>exclude</code> list. \nThe output <code>filepath</code> name is <code>'potential.dat'</code> by default.</p>\n\n<p>Energy values are saved to meV by dafault, unless specified in <code>energy</code>.\nOnly change the energy units if you know what you are doing;\nremember that default energy units in QRotor are meV!</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">folder</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">filepath</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;potential.csv&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">include</span><span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">&#39;.out&#39;</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">exclude</span><span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">&#39;slurm-&#39;</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">energy</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;meV&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">comment</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "qrotor.potential.merge", "modulename": "qrotor.potential", "qualname": "merge", "kind": "function", "doc": "<p>Add or subtract potentials from different systems.</p>\n\n<p>Adds the potential values from the systems in <code>add</code>,\nremoves the ones from <code>subtract</code>.\nAll systems will be interpolated to the bigger gridsize if needed.</p>\n\n<p>A copy of the first System will be returned with the resulting potential values,\nwith an optional <code>comment</code> if indicated.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">add</span><span class=\"o\">=</span><span class=\"p\">[]</span>, </span><span class=\"param\"><span class=\"n\">subtract</span><span class=\"o\">=</span><span class=\"p\">[]</span>, </span><span class=\"param\"><span class=\"n\">comment</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">qrotor</span><span class=\"o\">.</span><span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">System</span>:</span></span>", "funcdef": "def"}, {"fullname": "qrotor.potential.scale", "modulename": "qrotor.potential", "qualname": "scale", "kind": "function", "doc": "<p>Returns a copy of <code>system</code> with potential values scaled by a <code>factor</code>.</p>\n\n<p>An optional <code>comment</code> can be included.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">system</span><span class=\"p\">:</span> <span class=\"n\">qrotor</span><span class=\"o\">.</span><span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">System</span>,</span><span class=\"param\">\t<span class=\"n\">factor</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">comment</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">qrotor</span><span class=\"o\">.</span><span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">System</span>:</span></span>", "funcdef": "def"}, {"fullname": "qrotor.potential.interpolate", "modulename": "qrotor.potential", "qualname": "interpolate", "kind": "function", "doc": "<p>Interpolates the current <code>System.potential_values</code>\nto a new grid of size <code>System.gridsize</code>.</p>\n\n<p>This basic function is called by <code>qrotor.solve.potential()</code>,\nwhich is the recommended way to interpolate potentials.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">system</span><span class=\"p\">:</span> <span class=\"n\">qrotor</span><span class=\"o\">.</span><span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">System</span></span><span class=\"return-annotation\">) -> <span class=\"n\">qrotor</span><span class=\"o\">.</span><span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">System</span>:</span></span>", "funcdef": "def"}, {"fullname": "qrotor.potential.solve", "modulename": "qrotor.potential", "qualname": "solve", "kind": "function", "doc": "<p>Solves <code>System.potential_values</code>\naccording to the <code>System.potential_name</code>,\nreturning the new <code>potential_values</code>.\nAvaliable potential names are <code>zero</code>, <code>sine</code> and <code>titov2023</code>.</p>\n\n<p>If <code>System.potential_name</code> is not present or not recognised,\nthe current <code>System.potential_values</code> are used.</p>\n\n<p>This basic function is called by <code>qrotor.solve.potential()</code>,\nwhich is the recommended way to solve potentials.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">system</span><span class=\"p\">:</span> <span class=\"n\">qrotor</span><span class=\"o\">.</span><span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">System</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "qrotor.potential.zero", "modulename": "qrotor.potential", "qualname": "zero", "kind": "function", "doc": "<p>Zero potential.</p>\n\n<p>$V(x) = 0$</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">system</span><span class=\"p\">:</span> <span class=\"n\">qrotor</span><span class=\"o\">.</span><span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">System</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "qrotor.potential.sine", "modulename": "qrotor.potential", "qualname": "sine", "kind": "function", "doc": "<p>Sine potential.</p>\n\n<p>$V(x) = C_0 + \\frac{C_1}{2} sin(x C_2 + C_3)$<br />\nWith $C_0$ as the potential offset,\n$C_1$ as the max potential value (without considering the offset),\n$C_2$ as the frequency, and $C_3$ as the phase.\nIf no <code>System.potential_constants</code> are provided, defaults to $sin(3x)$</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">system</span><span class=\"p\">:</span> <span class=\"n\">qrotor</span><span class=\"o\">.</span><span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">System</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "qrotor.potential.cosine", "modulename": "qrotor.potential", "qualname": "cosine", "kind": "function", "doc": "<p>Cosine potential.</p>\n\n<p>$V(x) = C_0 + \\frac{C_1}{2} cos(x C_2 + C_3)$<br />\nWith $C_0$ as the potential offset,\n$C_1$ as the max potential value (without considering the offset),\n$C_2$ as the frequency, and $C_3$ as the phase.\nIf no <code>System.potential_constants</code> are provided, defaults to $cos(3x)$</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">system</span><span class=\"p\">:</span> <span class=\"n\">qrotor</span><span class=\"o\">.</span><span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">System</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "qrotor.potential.titov2023", "modulename": "qrotor.potential", "qualname": "titov2023", "kind": "function", "doc": "<p>Potential energy function of the hindered methyl rotor, from\n<a href=\"https://link.aps.org/doi/10.1103/PhysRevMaterials.7.073402\">K. Titov et al., Phys. Rev. Mater. 7, 073402 (2023)</a>.  </p>\n\n<p>$V(x) = C_0 + C_1 sin(3x) + C_2 cos(3x) + C_3 sin(6x) + C_4 cos(6x)$<br />\nDefault constants are <code>qrotor.constants.constants_titov2023</code>[0].</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">system</span><span class=\"p\">:</span> <span class=\"n\">qrotor</span><span class=\"o\">.</span><span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">System</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "qrotor.rotate", "modulename": "qrotor.rotate", "kind": "module", "doc": "<h1 id=\"description\">Description</h1>\n\n<p>This submodule contains tools to rotate molecular structures.\nWorks with Quantum ESPRESSO input files.</p>\n\n<h1 id=\"index\">Index</h1>\n\n<table>\n<thead>\n<tr>\n  <th></th>\n  <th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td><code>structure_qe()</code></td>\n  <td>Rotate specific atoms from a Quantum ESPRESSO input file</td>\n</tr>\n<tr>\n  <td><code>rotate_coords()</code></td>\n  <td>Rotate a specific list of coordinates</td>\n</tr>\n</tbody>\n</table>\n\n<hr />\n"}, {"fullname": "qrotor.rotate.structure_qe", "modulename": "qrotor.rotate", "qualname": "structure_qe", "kind": "function", "doc": "<p>Rotates atoms from a Quantum ESPRESSO input file.</p>\n\n<p>Takes a <code>filepath</code> with a molecular structure, and three or more atomic <code>positions</code> (list).\nThese input positions can be approximate, and are used to identify the target atoms.\nThe decimal precision in the search for these positions is controlled by <code>precision</code>.</p>\n\n<p>It rotates the atoms by a specific <code>angle</code> in degrees.\nAdditionally, if <code>repeat = True</code> it repeats the same rotation over the whole circunference.\nFinally, it writes the rotated structure(s) to a new structural file(s).\nReturns a list with the output filename(s).</p>\n\n<p>By default, the rotation axis is defined by the perpendicular vector\npassing through the geometrical center of the first three points.\nTo override this and instead use the vector between the first two atoms\nas the rotation axis, set <code>use_centroid = False</code>.</p>\n\n<p><strong>WARNING: The <code>positions</code> list is order-sensitive</strong>.\nIf you rotate more than one chemical group in a structure,\nbe sure to follow the same direction for each group (e.g. all clockwise)\nto ensure that all axes of rotation point in the same direction.</p>\n\n<p>To debug, <code>show_axis = True</code> adds two additional helium atoms as the rotation vector.</p>\n\n<p>The resulting rotational potential can be compiled to a CSV file with <code>qrotor.potential.from_qe()</code>.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">filepath</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">positions</span><span class=\"p\">:</span> <span class=\"nb\">list</span>,</span><span class=\"param\">\t<span class=\"n\">angle</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">repeat</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">precision</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">use_centroid</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">show_axis</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "qrotor.rotate.rotate_coords", "modulename": "qrotor.rotate", "qualname": "rotate_coords", "kind": "function", "doc": "<p>Rotates geometrical coordinates.</p>\n\n<p>Takes a list of atomic <code>positions</code> in cartesian coordinates, as\n<code>[[x1,y1,z1], [x2,y2,z2], [x3,y3,z3], [etc]</code>.\nThen rotates said coordinates by a given <code>angle</code> in degrees.\nReturns a list with the updated positions.</p>\n\n<p>By default, the rotation vector is defined by the perpendicular\npassing through the geometrical center of the first three points.\nTo override this and use the vector between the first two atoms\nas the rotation axis, set <code>use_centroid = False</code>.</p>\n\n<p><strong>WARNING: The <code>positions</code> list is order-sensitive</strong>.\nIf you rotate more than one chemical group in a structure,\nbe sure to follow the same direction for each group (e.g. all clockwise)\nto ensure that all rotation vectors point in the same direction.</p>\n\n<p>If <code>show_axis = True</code> it returns two additional coordinates at the end of the list,\nwith the centroid and the rotation vector. Only works with <code>use_centroid = True</code>.</p>\n\n<p>The rotation uses Rodrigues' rotation formula,\npowered by <a href=\"https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.transform.Rotation.from_rotvec.html#scipy.spatial.transform.Rotation.from_rotvec\"><code>scipy.spatial.transform.Rotation.from_rotvec</code></a>.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">positions</span><span class=\"p\">:</span> <span class=\"nb\">list</span>,</span><span class=\"param\">\t<span class=\"n\">angle</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">use_centroid</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">show_axis</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "qrotor.solve", "modulename": "qrotor.solve", "kind": "module", "doc": "<h1 id=\"description\">Description</h1>\n\n<p>This module is used to solve any given quantum system.</p>\n\n<p>Although the functions of this module can be used independently,\nit is highly recommended to use the methods <code>System.solve()</code> or\n<code>System.solve_potential()</code> instead to solve the whole quantum system\nor just the potential values.\nThese user methods perform all calculations automatically,\nsee <code>qrotor.system.System.solve()</code> and\n<code>qrotor.system.System.solve_potential()</code> respectively for more details.</p>\n\n<p>This documentation page is left for reference and advanced users only.</p>\n\n<h1 id=\"index\">Index</h1>\n\n<table>\n<thead>\n<tr>\n  <th></th>\n  <th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td><code>energies()</code></td>\n  <td>Solve the quantum system, including eigenvalues and eigenvectors</td>\n</tr>\n<tr>\n  <td><code>potential()</code></td>\n  <td>Solve the potential values of the system</td>\n</tr>\n<tr>\n  <td><code>schrodinger()</code></td>\n  <td>Solve the Schr\u00f6diger equation for the system</td>\n</tr>\n<tr>\n  <td><code>hamiltonian_matrix()</code></td>\n  <td>Calculate the hamiltonian matrix of the system</td>\n</tr>\n<tr>\n  <td><code>laplacian_matrix()</code></td>\n  <td>Calculate the second derivative matrix for a given grid</td>\n</tr>\n<tr>\n  <td><code>excitations()</code></td>\n  <td>Get excitation levels and tunnel splitting energies</td>\n</tr>\n<tr>\n  <td><code>E_levels</code></td>\n  <td>Group a list of degenerated eigenvalues by energy levels</td>\n</tr>\n</tbody>\n</table>\n\n<hr />\n"}, {"fullname": "qrotor.solve.energies", "modulename": "qrotor.solve", "qualname": "energies", "kind": "function", "doc": "<p>Solves the quantum <code>system</code>.</p>\n\n<p>This includes solving the potential, the eigenvalues and the eigenvectors.</p>\n\n<p>The resulting System object is saved with pickle to <code>filename</code> if specified.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">system</span><span class=\"p\">:</span> <span class=\"n\">qrotor</span><span class=\"o\">.</span><span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">System</span>,</span><span class=\"param\">\t<span class=\"n\">filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">qrotor</span><span class=\"o\">.</span><span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">System</span>:</span></span>", "funcdef": "def"}, {"fullname": "qrotor.solve.potential", "modulename": "qrotor.solve", "qualname": "potential", "kind": "function", "doc": "<p>Solves the potential values of the <code>system</code>.</p>\n\n<p>Creates a grid if not yet present.\nIt also interpolates the potential if <code>system.gridsize</code> is larger than the current grid;\noptionally, an alternative <code>gridsize</code> can be specified.</p>\n\n<p>It then solves the potential according to the potential name.\nThen it applies extra operations, such as removing the potential offset\nif <code>system.correct_potential_offset = True</code>.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">system</span><span class=\"p\">:</span> <span class=\"n\">qrotor</span><span class=\"o\">.</span><span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">System</span>,</span><span class=\"param\">\t<span class=\"n\">gridsize</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">qrotor</span><span class=\"o\">.</span><span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">System</span>:</span></span>", "funcdef": "def"}, {"fullname": "qrotor.solve.schrodinger", "modulename": "qrotor.solve", "qualname": "schrodinger", "kind": "function", "doc": "<p>Solves the Schr\u00f6dinger equation for a given <code>system</code>.</p>\n\n<p>Uses ARPACK in shift-inverse mode to solve the hamiltonian sparse matrix.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">system</span><span class=\"p\">:</span> <span class=\"n\">qrotor</span><span class=\"o\">.</span><span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">System</span></span><span class=\"return-annotation\">) -> <span class=\"n\">qrotor</span><span class=\"o\">.</span><span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">System</span>:</span></span>", "funcdef": "def"}, {"fullname": "qrotor.solve.hamiltonian_matrix", "modulename": "qrotor.solve", "qualname": "hamiltonian_matrix", "kind": "function", "doc": "<p>Calculates the Hamiltonian sparse matrix for a given <code>system</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">system</span><span class=\"p\">:</span> <span class=\"n\">qrotor</span><span class=\"o\">.</span><span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">System</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "qrotor.solve.laplacian_matrix", "modulename": "qrotor.solve", "qualname": "laplacian_matrix", "kind": "function", "doc": "<p>Calculates the Laplacian (second derivative) matrix for a given <code>grid</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">grid</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "qrotor.solve.excitations", "modulename": "qrotor.solve", "qualname": "excitations", "kind": "function", "doc": "<p>Calculate the excitation levels and the tunnel splitting energies of a system.</p>\n\n<p>Automatically detects degenerated energy levels by looking at significant jumps\nbetween consecutive eigenvalues. Within each level, finds two subgroups\nto calculate tunnel splittings. Stops when energies reach the maximum potential.</p>\n\n<p>Excitations are calculated as the energy difference between the mean energy of the\nground state level and the mean energy of each excited level.</p>\n\n<p>Tunnel splittings are calculated as the difference between the mean values of\nthe two subgroups within each degenerate level.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">system</span><span class=\"p\">:</span> <span class=\"n\">qrotor</span><span class=\"o\">.</span><span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">System</span></span><span class=\"return-annotation\">) -> <span class=\"n\">qrotor</span><span class=\"o\">.</span><span class=\"n\">system</span><span class=\"o\">.</span><span class=\"n\">System</span>:</span></span>", "funcdef": "def"}, {"fullname": "qrotor.solve.E_levels", "modulename": "qrotor.solve", "qualname": "E_levels", "kind": "function", "doc": "<p>Group a list of degenerated eigenvalues by energy levels.</p>\n\n<p>Automatically detects degenerated energy levels by\nlooking at significant jumps between consecutive eigenvalues.</p>\n\n<p>An optional <code>vmax</code> can be specified,\nto avoid including too many eigenvalues\nabove a certain potential maximum.\nOnly two more eigenvalues are considered after <code>vmax</code>,\nto properly detect energy levels around the maximum.</p>\n\n<p>Example:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">levels</span><span class=\"p\">,</span> <span class=\"n\">deg</span> <span class=\"o\">=</span> <span class=\"n\">qr</span><span class=\"o\">.</span><span class=\"n\">solve</span><span class=\"o\">.</span><span class=\"n\">E_levels</span><span class=\"p\">(</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mf\">1.1</span><span class=\"p\">,</span> <span class=\"mf\">1.2</span><span class=\"p\">,</span> <span class=\"mf\">1.3</span><span class=\"p\">,</span> <span class=\"mf\">5.4</span><span class=\"p\">,</span> <span class=\"mf\">5.5</span><span class=\"p\">,</span> <span class=\"mf\">5.6</span><span class=\"p\">]))</span>\n<span class=\"n\">levels</span>  <span class=\"c1\"># [array([1.1, 1.2, 1.3]), array([5.4, 5.5, 5.6])]</span>\n<span class=\"n\">deg</span>  <span class=\"c1\"># 3</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">eigenvalues</span>, </span><span class=\"param\"><span class=\"n\">vmax</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "qrotor.system", "modulename": "qrotor.system", "kind": "module", "doc": "<h1 id=\"description\">Description</h1>\n\n<p>The <code>System</code> object contains all the information needed for a single QRotor calculation.\nThis class can be loaded directly as <code>qrotor.System()</code>.</p>\n\n<hr />\n"}, {"fullname": "qrotor.system.System", "modulename": "qrotor.system", "qualname": "System", "kind": "class", "doc": "<p>Quantum system.</p>\n\n<p>Contains all the data for a single QRotor calculation, with both inputs and outputs.</p>\n\n<p>Energy units are in meV and angles are in radians, unless stated otherwise.</p>\n"}, {"fullname": "qrotor.system.System.__init__", "modulename": "qrotor.system", "qualname": "System.__init__", "kind": "function", "doc": "<p>A new quantum system can be instantiated as <code>system = qrotor.System()</code>.\nThis new system will contain the default values listed above.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">comment</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">searched_E</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">21</span>,</span><span class=\"param\">\t<span class=\"n\">correct_potential_offset</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">save_eigenvectors</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">group</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">B</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">(</span><span class=\"mf\">0.6452195002679675</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">gridsize</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">200000</span>,</span><span class=\"param\">\t<span class=\"n\">grid</span><span class=\"o\">=</span><span class=\"p\">[]</span>,</span><span class=\"param\">\t<span class=\"n\">potential_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">potential_constants</span><span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">potential_values</span><span class=\"o\">=</span><span class=\"p\">[]</span></span>)</span>"}, {"fullname": "qrotor.system.System.version", "modulename": "qrotor.system", "qualname": "System.version", "kind": "variable", "doc": "<p>Version of the package used to generate the data.</p>\n"}, {"fullname": "qrotor.system.System.comment", "modulename": "qrotor.system", "qualname": "System.comment", "kind": "variable", "doc": "<p>Custom comment for the dataset.</p>\n", "annotation": ": str"}, {"fullname": "qrotor.system.System.searched_E", "modulename": "qrotor.system", "qualname": "System.searched_E", "kind": "variable", "doc": "<p>Number of energy eigenvalues to be searched.</p>\n", "annotation": ": int"}, {"fullname": "qrotor.system.System.correct_potential_offset", "modulename": "qrotor.system", "qualname": "System.correct_potential_offset", "kind": "variable", "doc": "<p>Correct the potential offset as <code>V - min(V)</code> or not.</p>\n", "annotation": ": bool"}, {"fullname": "qrotor.system.System.save_eigenvectors", "modulename": "qrotor.system", "qualname": "System.save_eigenvectors", "kind": "variable", "doc": "<p>Save or not the eigenvectors. Final file size will be bigger.</p>\n", "annotation": ": bool"}, {"fullname": "qrotor.system.System.group", "modulename": "qrotor.system", "qualname": "System.group", "kind": "variable", "doc": "<p>Chemical group, methyl or amine: <code>'CH3'</code>, <code>'CD3'</code>, <code>'NH3'</code>, <code>'ND3'</code>.</p>\n\n<p>Can be used to set the value of <code>B</code> automatically at startup.\nIt can also be configured afterwards with <code>System.set_group()</code>.\nThis group can be used as metadata to analyse different datasets.</p>\n", "annotation": ": str"}, {"fullname": "qrotor.system.System.B", "modulename": "qrotor.system", "qualname": "System.B", "kind": "variable", "doc": "<p>Rotational inertia, as in $B=\\frac{\\hbar^2}{2I}$.</p>\n\n<p>Defaults to the value for a methyl group.</p>\n", "annotation": ": float"}, {"fullname": "qrotor.system.System.gridsize", "modulename": "qrotor.system", "qualname": "System.gridsize", "kind": "variable", "doc": "<p>Number of points in the grid.</p>\n", "annotation": ": int"}, {"fullname": "qrotor.system.System.grid", "modulename": "qrotor.system", "qualname": "System.grid", "kind": "variable", "doc": "<p>The grid with the points to be used in the calculation.</p>\n\n<p>Can be set automatically over $2 \\pi$ with <code>System.set_grid()</code>.\nUnits must be in radians.</p>\n"}, {"fullname": "qrotor.system.System.potential_name", "modulename": "qrotor.system", "qualname": "System.potential_name", "kind": "variable", "doc": "<p>Name of the desired potential: <code>'zero'</code>, <code>'titov2023'</code>, <code>'test'</code>...</p>\n\n<p>If empty or unrecognised, the custom potential values inside <code>System.potential_values</code> will be used.</p>\n", "annotation": ": str"}, {"fullname": "qrotor.system.System.potential_constants", "modulename": "qrotor.system", "qualname": "System.potential_constants", "kind": "variable", "doc": "<p>List of constants to be used in the calculation of the potential energy, in the <code>qrotor.potential</code> module.</p>\n", "annotation": ": list"}, {"fullname": "qrotor.system.System.potential_values", "modulename": "qrotor.system", "qualname": "System.potential_values", "kind": "variable", "doc": "<p>Numpy <a href=\"https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html\">ndarray</a> with the potential values for each point in the grid.</p>\n\n<p>Can be calculated with a function available in the <code>qrotor.potential</code> module,\nor loaded externally with the <code>qrotor.potential.load()</code> function.\nPotential energy units must be in meV.</p>\n"}, {"fullname": "qrotor.system.System.potential_offset", "modulename": "qrotor.system", "qualname": "System.potential_offset", "kind": "variable", "doc": "<p><code>min(V)</code> before offset correction when <code>correct_potential_offset = True</code></p>\n", "annotation": ": float"}, {"fullname": "qrotor.system.System.potential_min", "modulename": "qrotor.system", "qualname": "System.potential_min", "kind": "variable", "doc": "<p><code>min(V)</code></p>\n", "annotation": ": float"}, {"fullname": "qrotor.system.System.potential_max", "modulename": "qrotor.system", "qualname": "System.potential_max", "kind": "variable", "doc": "<p><code>max(V)</code></p>\n", "annotation": ": float"}, {"fullname": "qrotor.system.System.eigenvectors", "modulename": "qrotor.system", "qualname": "System.eigenvectors", "kind": "variable", "doc": "<p>Eigenvectors, if <code>save_eigenvectors</code> is True. Beware of the file size.</p>\n"}, {"fullname": "qrotor.system.System.eigenvalues", "modulename": "qrotor.system", "qualname": "System.eigenvalues", "kind": "variable", "doc": "<p>Calculated eigenvalues of the system. In meV.</p>\n"}, {"fullname": "qrotor.system.System.E_levels", "modulename": "qrotor.system", "qualname": "System.E_levels", "kind": "variable", "doc": "<p>List of <code>eigenvalues</code> grouped by energy levels, found below <code>potential_max</code>.</p>\n", "annotation": ": list"}, {"fullname": "qrotor.system.System.deg", "modulename": "qrotor.system", "qualname": "System.deg", "kind": "variable", "doc": "<p>Estimated degeneracy of the <code>E_levels</code> found below <code>potential_max</code>.</p>\n", "annotation": ": float"}, {"fullname": "qrotor.system.System.excitations", "modulename": "qrotor.system", "qualname": "System.excitations", "kind": "variable", "doc": "<p>Torsional excitations, as the difference between each energy level with respect to the ground state.</p>\n\n<p>Considers the means between degenerated eigenvalues for all energy levels below <code>potential_max</code>.</p>\n", "annotation": ": list"}, {"fullname": "qrotor.system.System.splittings", "modulename": "qrotor.system", "qualname": "System.splittings", "kind": "variable", "doc": "<p>Tunnel splitting energies, for every degenerated energy level.</p>\n\n<p>Calculated for all <code>E_levels</code> as the difference between\nthe mean of the eigenvalues from A and the mean of the eigenvalues from E,\nsee <a href=\"https://doi.org/10.1119/1.1538575\">R. M. Dimeo, American Journal of Physics 71, 885\u2013893 (2003)</a>.</p>\n", "annotation": ": list"}, {"fullname": "qrotor.system.System.energy_barrier", "modulename": "qrotor.system", "qualname": "System.energy_barrier", "kind": "variable", "doc": "<p>Activation energy or energy barrier, from the ground torsional state to the top of the potential barrier, <code>max(V) - min(eigenvalues)</code></p>\n", "annotation": ": float"}, {"fullname": "qrotor.system.System.runtime", "modulename": "qrotor.system", "qualname": "System.runtime", "kind": "variable", "doc": "<p>Time taken to solve the eigenvalues.</p>\n", "annotation": ": float"}, {"fullname": "qrotor.system.System.solve", "modulename": "qrotor.system", "qualname": "System.solve", "kind": "function", "doc": "<p>Default user method to solve the quantum system.</p>\n\n<p>The potential can be interpolated to a <code>new_gridsize</code>.</p>\n\n<p>Same as running <code>qrotor.solve.energies(System)</code>\nwith an optional new gridsize.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">new_gridsize</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "qrotor.system.System.solve_potential", "modulename": "qrotor.system", "qualname": "System.solve_potential", "kind": "function", "doc": "<p>Default user method to quickly solve the potential of the quantum system.</p>\n\n<p>This method does not solve the energies of the system,\nit just computes the potential and sets <code>System.potential_max</code>,\n<code>System.potential_min</code> and <code>System.potential_offset</code> accordingly.\nTo solve the potential AND the energies, check <code>System.solve()</code>.</p>\n\n<p>The potential can be interpolated to a <code>new_gridsize</code>.</p>\n\n<p>Same as running <code>qrotor.solve.potential(System)</code>\nwith an optional new gridsize.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">new_gridsize</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "qrotor.system.System.change_phase", "modulename": "qrotor.system", "qualname": "System.change_phase", "kind": "function", "doc": "<p>Apply a phase shift to the grid and potential values.</p>\n\n<p>The <code>phase</code> should be a multiple of $\\pi$ (e.g., 3/2 for $3\\pi/2$).\nThe resulting grid will be expressed between $-2\\pi$ and $2\\pi$.</p>\n\n<p>The System is solved immediately after the phase change.\nThis last step ensures that all eigenvalues and wavefunctions are correct.\nYou can override this step with <code>calculate = False</code>,\nbut remember to solve the System later!</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">phase</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">calculate</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "qrotor.system.System.set_grid", "modulename": "qrotor.system", "qualname": "System.set_grid", "kind": "function", "doc": "<p>Sets the <code>System.grid</code> to the specified <code>gridsize</code> from 0 to $2\\pi$.</p>\n\n<p>If the system had a previous grid and potential values,\nit will interpolate those values to the new gridsize,\nusing <code>qrotor.potential.interpolate()</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">gridsize</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "qrotor.system.System.set_group", "modulename": "qrotor.system", "qualname": "System.set_group", "kind": "function", "doc": "<p>Normalise <code>System.group</code> name, and set <code>System.B</code> based on it.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">group</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">B</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "qrotor.system.System.reduce_size", "modulename": "qrotor.system", "qualname": "System.reduce_size", "kind": "function", "doc": "<p>Discard data that takes too much space,\nlike eigenvectors, potential values and grids.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "qrotor.system.System.summary", "modulename": "qrotor.system", "qualname": "System.summary", "kind": "function", "doc": "<p>Returns a dict with a summary of the System data.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "qrotor.systems", "modulename": "qrotor.systems", "kind": "module", "doc": "<h1 id=\"description\">Description</h1>\n\n<p>This module contains utility functions to handle multiple <code>qrotor.system</code> calculations.\nThese are commonly used as a list of <code>System</code> objects.</p>\n\n<h1 id=\"index\">Index</h1>\n\n<table>\n<thead>\n<tr>\n  <th></th>\n  <th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td><code>as_list()</code></td>\n  <td>Ensures that a list only contains System objects</td>\n</tr>\n<tr>\n  <td><code>save_energies()</code></td>\n  <td>Save the energy eigenvalues for all systems to a CSV</td>\n</tr>\n<tr>\n  <td><code>save_splittings()</code></td>\n  <td>Save the tunnel splitting energies for all systems to a CSV</td>\n</tr>\n<tr>\n  <td><code>get_energies()</code></td>\n  <td>Get the eigenvalues from all systems</td>\n</tr>\n<tr>\n  <td><code>get_gridsizes()</code></td>\n  <td>Get all gridsizes</td>\n</tr>\n<tr>\n  <td><code>get_runtimes()</code></td>\n  <td>Get all runtimes</td>\n</tr>\n<tr>\n  <td><code>get_groups()</code></td>\n  <td>Get the chemical groups in use</td>\n</tr>\n<tr>\n  <td><code>get_ideal_E()</code></td>\n  <td>Calculate the ideal energy for a specified level</td>\n</tr>\n<tr>\n  <td><code>sort_by_gridsize()</code></td>\n  <td>Sort systems by gridsize</td>\n</tr>\n<tr>\n  <td><code>reduce_size()</code></td>\n  <td>Discard data that takes too much space</td>\n</tr>\n<tr>\n  <td><code>summary()</code></td>\n  <td>Print a summary of a System or list of Systems</td>\n</tr>\n</tbody>\n</table>\n\n<hr />\n"}, {"fullname": "qrotor.systems.as_list", "modulename": "qrotor.systems", "qualname": "as_list", "kind": "function", "doc": "<p>Ensures that <code>systems</code> is a list of System objects.</p>\n\n<p>If it is a System, returns a list with that System as the only element.\nIf it is neither a list nor a System,\nor if the list does not contain only System objects,\nit raises an error.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">systems</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "qrotor.systems.save_energies", "modulename": "qrotor.systems", "qualname": "save_energies", "kind": "function", "doc": "<p>Save the energy eigenvalues for all <code>systems</code> to a eigenvalues.csv file.</p>\n\n<p>Returns a Pandas Dataset with <code>System.comment</code> columns and <code>System.eigenvalues</code> values.</p>\n\n<p>The output file can be changed with <code>filepath</code>,\nor set to null to avoid saving the dataset.\nA <code>comment</code> can be included at the top of the file.\nNote that <code>System.comment</code> must not include commas (<code>,</code>).</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">systems</span><span class=\"p\">:</span> <span class=\"nb\">list</span>,</span><span class=\"param\">\t<span class=\"n\">comment</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">filepath</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;eigenvalues.csv&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "qrotor.systems.save_splittings", "modulename": "qrotor.systems", "qualname": "save_splittings", "kind": "function", "doc": "<p>Save the tunnel splitting energies for all <code>systems</code> to a splittings.csv file.</p>\n\n<p>Returns a Pandas Dataset with <code>System.comment</code> columns and <code>System.splittings</code> values.</p>\n\n<p>The output file can be changed with <code>filepath</code>,\nor set to null to avoid saving the dataset.\nA <code>comment</code> can be included at the top of the file.\nNote that <code>System.comment</code> must not include commas (<code>,</code>).\nDifferent splitting lengths across systems are allowed - missing values will be NaN.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">systems</span><span class=\"p\">:</span> <span class=\"nb\">list</span>,</span><span class=\"param\">\t<span class=\"n\">comment</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">filepath</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;splittings.csv&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>:</span></span>", "funcdef": "def"}, {"fullname": "qrotor.systems.get_energies", "modulename": "qrotor.systems", "qualname": "get_energies", "kind": "function", "doc": "<p>Get a list with all lists of eigenvalues from all systems.</p>\n\n<p>If no eigenvalues are present for a particular system, appends None.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">systems</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "qrotor.systems.get_gridsizes", "modulename": "qrotor.systems", "qualname": "get_gridsizes", "kind": "function", "doc": "<p>Get a list with all gridsize values.</p>\n\n<p>If no gridsize value is present for a particular system, appends None.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">systems</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "qrotor.systems.get_runtimes", "modulename": "qrotor.systems", "qualname": "get_runtimes", "kind": "function", "doc": "<p>Returns a list with all runtime values.</p>\n\n<p>If no runtime value is present for a particular system, appends None.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">systems</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "qrotor.systems.get_groups", "modulename": "qrotor.systems", "qualname": "get_groups", "kind": "function", "doc": "<p>Returns a list with all <code>System.group</code> values.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">systems</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "qrotor.systems.get_ideal_E", "modulename": "qrotor.systems", "qualname": "get_ideal_E", "kind": "function", "doc": "<p>Calculates the ideal energy for a specified <code>E_level</code>.</p>\n\n<p>To be used in convergence tests with <code>potential_name = 'zero'</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">E_level</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "qrotor.systems.sort_by_gridsize", "modulename": "qrotor.systems", "qualname": "sort_by_gridsize", "kind": "function", "doc": "<p>Sorts a list of System objects by <code>System.gridsize</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">systems</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "qrotor.systems.reduce_size", "modulename": "qrotor.systems", "qualname": "reduce_size", "kind": "function", "doc": "<p>Discard data that takes too much space.</p>\n\n<p>Removes eigenvectors, potential values and grids,\nfor all System values inside the <code>systems</code> list.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">systems</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "qrotor.systems.summary", "modulename": "qrotor.systems", "qualname": "summary", "kind": "function", "doc": "<p>Print a summary of a System or list of Systems.</p>\n\n<p>Print extra info with <code>verbose=True</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">systems</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();